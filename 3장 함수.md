## 목차  
- 작게 만들어라!  
	- 블록과 들여쓰기  
- 한 가지만 해라!  
	- 함수 내 섹션  
- 함수 당 추상화 수준은 하나로!  
	- 위에서 아래로 코드 읽기 : 내려가기 규칙  
- Switch문  
- 서술적인 이름을 사용하라!  
- 함수 인수  
	- 많이 쓰는 단항 형식  
	- 플래그 인수  
	- 이항 함수  
	- 삼항 함수  
	- 인수 객체  
	- 인수 목록  
	- 동사와 키워드  
- 부수 효과를 일으키지 마라!  
	- 출력 인수  
- 명령과 조회를 분리하라!  
- 오류코드보다 예외를 사용하라!  
	- Try/Catch 블록 뽑아내기  
	- 오류  처리도 한 가지 직업이다  
	- Error.java의 의존성 자석  
- 반복하지마라!  
- 구조적 프로그래밍  
- 함수를 어떻게 짜죠? 

### 작게 만들어라!
 - if 문/else 문/while 문 등에 들어가는 블록은 한줄로 (대게 그 안에서 함수를 호출함)
 
### 한 가지만 해라! 
 - 함수는 한가지를 잘해야한다, 한가지만 잘해야한다
 - 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행된다면 그 함수는 한가지 작업만 하는 것이다
 
### 함수당 추상화 수준은 하나로!
 - 함수당 추상화 수준은 하나로! 추상화 수준이 섞이면 읽는 사람이 헷갈린다


#### 나쁜 예
```java
public static String testableHtml(
  PageData pageData, boolean includeSuiteSetup
  ) throws Exception { 
    Wikipage wikipage = pageData.getWikiPage(); 
    StringBuffer buffer = new StringBuffer(); 
    // Test 페이지에 Setup 페이지 추가
    if (pageData.hasAttribute("Test")) {
      if (includeSuiteSetup) { 
        WikiPage suiteSetup = 
	  PageCrawlerlmpl.getlnheritedPage(
	        SuiteResponder.SUITE_SETUP_NAME, wikiPage
	  ); 
        if (suiteSetup != null) { 
	  wikiPagePath pagePath = 
	    suiteSetup.getPageCrawler().getFullPath(suiteSetup); 
	  String pagePathName = PathParser.render(pagePath); 
	  buffer.append("include -setup .") 
	        .append(pagePathName) 
		.append("\n"); 
	} 
    } 
    WikiPage setup = 
      PageCrawlerlmpl.getInheritedPage("SetUp", wikiPage); 
    if (setup != null) { 
      WikiPagePath setupPath = 
        wikiPage.getPageCrawler().getFullPath(setup); 
      String setupPathName = PathParser.render(setupPath); 
      buffer.append("!include -setup .") 
            .append(setupPathName) 
	    .append("\n");
    } 
  } 
  buffer.append(pageData.getContent()); 
  // Test 페이지에 TearDown페이지 추가
  if (pageData.hasAttribute("Test")) {
    WikiPage teardown = pageCrawlerlmpl.getInheritedPage("TearDown", wikiPage); 
    if (teardown != null) { 
      WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardown); 
      String tearDownPathName = PathParser.render(tearDownPath); 
      buffer.append("\n") 
            .append("!include -teardown .") 
	    .append(tearDownPathName) 
	    .append("\n"); 
    } 
    if (includeSuiteSetup) { 
      WikiPage suiteTeardown = PageCrawlerlmpl.getlnheritedPage( 
        SuiteResponder.SUITE_TEARDOWN_NAME, wikiPage 
      ); 
      if (suiteTeardown != null) { 
        Wikipagepath pagePath = suiteTeardown.getPageCrawler().getFullPath (suiteTeardown); 
        String pagePathName = PathParser.render(pagePath); 
        buffer.append("!include -teardown .") 
              .append(pagePathName) 
	      .append("\n"); 
      } 
    } 
  } 
pageData.setContent(buffer.toString()); 
return pageData.getHtml(); 
}
```
- 추상화 수준이 너무 다양함
+ 낮은 추상화 ex) buffer.append("\n")
+ 중간 추상화 ex) PathParser.render(setupPath)
+ 높은 추상화 ex) pageData.getHtml();
- if문의 중첩이 섞여있으며 이상함 flag를 사용함
- 코드가 너무 김


#### 좋은 예
```java
public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception {
	boolean isTestPage = pageData.hasAttribute("Test"); 
	if (isTestPage) {
		WikiPage testPage = pageData.getWikiPage(); 
		StringBuffer newPageContent = new StringBuffer(); 
		includeSetupPages(testPage, newPageContent, isSuite); 
		newPageContent.append(pageData.getContent()); 
		includeTeardownPages(testPage, newPageContent, isSuite); 
		pageData.setContent(newPageContent.toString());
	}
	return pageData.getHtml(); 
}
```
- 추상화 수준을 2개로 줄였다
- 코드를 더 짧게 만들었다

#### 더 좋은 예
 ```java
public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { 
	if (isTestPage(pageData)) 
		includeSetupAndTeardownPages(pageData, isSuite); 
	return pageData.getHtml();
}
```
- if 문 안에 들어가는 함수는 1개로
- 들여쓰기 수준은 2단 이하로
- 함수 이름을 적절히 지었다


### Switch문
- Switch문은 작게 만들기 어렵다. 피할 방법은 없다
- Switch문은 저차원 클래스에 숨기고 절대로 반복하지 말도록 하자

```java
public Money calculatePay(Employee e) throws InvalidEmployeeType {
	switch (e.type) { 
		case COMMISSIONED:
			return calculateCommissionedPay(e); 
		case HOURLY:
			return calculateHourlyPay(e); 
		case SALARIED:
			return calculateSalariedPay(e); 
		default:
			throw new InvalidEmployeeType(e.type); 
	}
}
```
- 함수가 길다
- 한가지 작업만 수행하지 않는다
- deliverPay(Emplyee e, Money pay) 같은 구조가 동일한 함수가 무한정 생성될 가능성이 있다

```java
public abstract class Employee {
	public abstract boolean isPayday();
	public abstract Money calculatePay();
	public abstract void deliverPay(Money pay);
}
-----------------
public interface EmployeeFactory {
	public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType; 
}
-----------------
public class EmployeeFactoryImpl implements EmployeeFactory {
	public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
		switch (r.type) {
			case COMMISSIONED:
				return new CommissionedEmployee(r) ;
			case HOURLY:
				return new HourlyEmployee(r);
			case SALARIED:
				return new SalariedEmploye(r);
			default:
				throw new InvalidEmployeeType(r.type);
		} 
	}
}
```

- switch문을 추상 팩토리에 숨긴다
- caculatePay, deliverPay같은 함수는 Employee 인터페이스를 거쳐 호출 될 수 있다


###서술적인 이름을 사용하라!
- ex) testableHTml -> SetupTeardownIncluder.render
- 이름이 길어도 괜찮다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 시간을 들여도 괜찮다.

###함수 인수
- 함수에서 상적인 인수 개수는 0개이다
- 삼항 이상은 피하자
- ex) includeSetupPageInto(new PageContent) 보다 includeSetupPage()가 이해하기 더 쉽다 (별로 중요하지 않은 new PageContent를 알아야한다)

####많이 쓰는 단항형식
- 함수에 수 1개를 넘기는 이유로 가장 흔한 경우 
   1) 질문을 던지는경우: boolean fileExissts("MyFile") 
   2) 인수를 변환해 리턴하는경우 : InputStream fileOpen("MyFile")-
   3) 이벤트 함수 : passwordAttempFailedNtimes(int attempts)
   
- 이 외에는 가급적 피한다

####플래그인수
플래그 인수는 추하다. 쓰지말자

####이항함수
- Point p = new Point(0,0) 는 적절하다

####삼항함수
- assertEquals(1.0, amount,.001) 이정도는 괜찮다.


 

